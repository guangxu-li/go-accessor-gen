package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// Method template for generating accessors.
const methodTemplate = `// Code generated by accessor generator. DO NOT EDIT.

package {{.PackageName}}

{{if .Imports}}import (
{{range .Imports}}
	{{.}}
{{end}}
)
{{end}}

{{range $struct := .Structs}}
{{range .Fields}}
{{if eq $.Mode "getter" "accessor"}}
{{if .PrimitivePointer}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Get{{ capitalizeFirstLetter .Name}}() (zero {{.DeferrencedFieldType}}) {
	if s == nil || s.{{.Name}} == nil {
		return zero
	}
	return *s.{{.Name}}
}
{{else}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Get{{ capitalizeFirstLetter .Name}}() (zero {{.Type}}) {
	if s == nil {
		return zero
	}
	return s.{{.Name}}
}
{{end}}
{{end}}
{{if eq $.Mode "setter" "accessor"}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Set{{ capitalizeFirstLetter .Name}}(val {{.Type}}) {
	s.{{.Name}} = val
}
{{end}}
{{end}}
{{end}}
`

const testTemplate = `// Code generated by accessor generator. DO NOT EDIT.

package {{.PackageName}}

import (
	"testing"
	"github.com/stretchr/testify/assert"
{{range .Imports}}{{.}}
{{end}}
)

{{range $struct := .Structs}}
{{range .Fields}}
{{if eq $.Mode "getter" "accessor"}}
func Test{{ capitalizeFirstLetter $struct.StructName}}_Get{{ capitalizeFirstLetter .Name}}(t *testing.T) {
	var zero {{if .PrimitivePointer}}{{.DeferrencedFieldType}}{{else}}{{.Type}}{{end}}
	nonZero := {{.NonZeroValue}}

	tests := []struct {
		name string
		obj  *{{$struct.StructName}}{{$struct.TypeParamsStr}}
		want {{if .PrimitivePointer}}{{.DeferrencedFieldType}}{{else}}{{.Type}}{{end}}
	}{
		{
			name: "nil receiver",
			obj: nil,
			want: zero,
		},
		{
			name: "default value",
			obj: new({{$struct.StructName}}{{$struct.TypeParamsStr}}),
			want: zero,
		},
		{
			name: "non-zero value",
			obj: &{{$struct.StructName}}{{$struct.TypeParamsStr}}{
				{{.Name}}: {{if .PrimitivePointer}}&{{else}}{{end}}nonZero,
			},
			want: nonZero,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.obj.Get{{ capitalizeFirstLetter .Name}}()
			assert.Equal(t, tt.want, got)
		})
	}
}
{{end}}

{{if eq $.Mode "setter" "accessor"}}
func Test{{ capitalizeFirstLetter $struct.StructName}}_Set{{ capitalizeFirstLetter .Name}}(t *testing.T) {
	nonZero := {{.NonZeroValue}}
	nonZero2 := {{.NonZeroValue2}}

	tests := []struct {
		name string
		obj *{{$struct.StructName}}{{$struct.TypeParamsStr}}
		input {{.Type}}
	}{
		{
			name: "default value",
			obj: &{{$struct.StructName}}{{$struct.TypeParamsStr}}{},
		},
		{
			name: "non-zero value",
			obj: &{{$struct.StructName}}{{$struct.TypeParamsStr}}{
				{{.Name}}: {{if .PrimitivePointer}}&{{else}}{{end}}nonZero,
			},
			input: {{if .PrimitivePointer}}&{{else}}{{end}}nonZero2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.obj.Set{{ capitalizeFirstLetter .Name}}(tt.input)
			assert.Equal(t, tt.input, tt.obj.{{.Name}})
		})
	}
}
{{end}}
{{end}}
{{end}}
`

func capitalizeFirstLetter(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func executeMethodTmpl(data *FileData) ([]byte, error) {
	return executeTmpl(data, methodTemplate)
}

func executeTestTmpl(data *FileData) ([]byte, error) {
	return executeTmpl(data, testTemplate)
}

func executeTmpl(data *FileData, tmpl string) ([]byte, error) {
	var output bytes.Buffer
	if err := template.Must(
		template.New("accessor_test").
			Funcs(template.FuncMap{"capitalizeFirstLetter": capitalizeFirstLetter}).
			Parse(tmpl),
	).Execute(&output, data); err != nil {
		return nil, fmt.Errorf("error generating output: %v", err)
	}

	return output.Bytes(), nil
}
