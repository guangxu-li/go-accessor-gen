package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// Method template for generating accessors.
const methodTemplate = `// Code generated by accessor generator. DO NOT EDIT.

package {{.PackageName}}

{{if .Imports}}import (
{{range .Imports}}
	{{.}}
{{end}}
)
{{end}}

{{range $struct := .Structs}}
{{range .Fields}}
{{if eq $.Mode "getter" "accessor"}}
{{if .PrimitivePointer}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Get{{ capitalizeFirstLetter .Name}}() (zero {{.DeferrencedFieldType}}) {
	if s == nil {
		return zero
	}
	return *s.{{.Name}}
}
{{else}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Get{{ capitalizeFirstLetter .Name}}() (zero {{.Type}}) {
	if s == nil {
		return zero
	}
	return s.{{.Name}}
}
{{end}}
{{end}}
{{if eq $.Mode "setter" "accessor"}}
func (s *{{$struct.StructName}}{{$struct.TypeParamsStr}}) Set{{ capitalizeFirstLetter .Name}}(val {{.Type}}) {
	s.{{.Name}} = val
}
{{end}}
{{end}}
{{end}}
`

func capitalizeFirstLetter(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func executeTmpl(data *FileData, filePath string) ([]byte, error) {
	var output bytes.Buffer
	tmpl := template.Must(
		template.New("accessor").
			Funcs(template.FuncMap{"capitalizeFirstLetter": capitalizeFirstLetter}).
			Parse(methodTemplate),
	)
	if err := tmpl.Execute(&output, data); err != nil {
		return nil, fmt.Errorf("error generating output: %v", err)
	}

	return output.Bytes(), nil
}
